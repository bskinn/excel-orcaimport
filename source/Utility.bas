Attribute VB_Name = "Utility"
'-------------------------------------------------------------------------------
' Name:        Utility (Module)
' Purpose:     Utility functions for ORCA Importer
'
' Author:      Brian Skinn
'                bskinn@alum.mit.edu
'
' Created:     29 Apr 2016
' Copyright:   (c) Brian Skinn 2016
' License:     The MIT License; see "license.txt" for full license terms
'                   and contributor agreement.
'
'       This file is part of ORCA Importer, an Excel VBA add-in providing
'       memoized import functionality for output generated by the ORCA
'       quantum chemistry software program package
'       (http://orcaforum.cec.mpg.de).
'
'       http://www.github.com/bskinn/excel-orcaimport
'
'-------------------------------------------------------------------------------

Option Explicit
Option Base 1

' Most (all?) of these functions will handle Arrays of any dimension base,
'  but all are configured to return Base 1 Arrays.  This is, in part,
'  in order to ensure that the Excel worksheet interface plays nicely
'  with them.

Public Function mNormalize(ByVal mtx As Variant) As Variant
    ' Normalize input matrix (2-norm) across the full contents
    '  of a 2-D Array
    '
    ' Raises RTE #13 (type mismatch) if matrixified version
    '  is not an Array
    
    Dim workVt() As Variant, iter1 As Long, iter2 As Long
    Dim accum As Double
    Dim mSpecs As Scripting.Dictionary
    
    ' Matrixify the input
    mtx = matrixify(mtx)
    
    ' Complain if it wasn't converted to an Array
    assertIsArray mtx
    
    ' Complain if it's not 2-D
    assertIs2D mtx
    
    ' Store the dimensions for convenience and redim the working Variant
    Set mSpecs = mtxSpecs(mtx)
    ReDim workVt(1 To mSpecs(msDim1), 1 To mSpecs(msDim2))
    
    ' Iterate over the whole thing and accumulate the squares of the elements
    accum = 0#
    For iter1 = mSpecs(msLB1) To mSpecs(msUB1)
        For iter2 = mSpecs(msLB2) To mSpecs(msUB2)
            accum = accum + mtx(iter1, iter2) ^ 2#
        Next iter2
    Next iter1
    
    ' Iterate again and store each normalized element to the working Variant
    For iter1 = 1 To mSpecs(msDim1)
        For iter2 = 1 To mSpecs(msDim2)
            workVt(iter1, iter2) = (1# / (accum ^ 0.5)) * _
                        mtx(mSpecs(msLB1) - 1 + iter1, mSpecs(msLB2) - 1 + iter2)
        Next iter2
    Next iter1
    
    ' Return the working matrix
    mNormalize = workVt
    
End Function

Public Function mDiag(ByVal vec As Variant) As Variant
    ' Convert an Nx1 or 1xN array to a square 2-D diagonal array
    '
    ' Raises RTE #13 (type mismatch) if vec is not a 1-D array
    
    Dim workVt() As Variant, mDim As Long, iter As Long
    Dim mSpecs As Scripting.Dictionary
    Dim wsf As WorksheetFunction
    
    ' Attach the wsf
    Set wsf = Application.WorksheetFunction
    
    ' Matrixify the input
    vec = matrixify(vec)
    
    ' Complain if it's not now an array
    assertIsArray vec
    
    ' Raise error if not a 2-D array
    assertIs2D vec
    
    ' Store the dimensions for convenience
    Set mSpecs = mtxSpecs(vec)
    
    ' Complain if it's not an Nx1 or 1xN array
    If Not (mSpecs(msLB1) = mSpecs(msUB1) Or mSpecs(msLB2) = mSpecs(msUB2)) Then
        ' N = 1 is allowable here, though trivial
        Err.Raise Number:=13, Description:="Type mismatch: 'vec' is not an Nx1 or 1xN Array"
    End If
    
    ' Store the length of the long dimension for convenience
    mDim = wsf.Max(mSpecs(msDim1), mSpecs(msDim2))
    
    ' Redimension the working Variant
    ReDim workVt(1 To mDim, 1 To mDim)
    
    ' Iterate to fill the work variable
    For iter = 1 To mDim
        If mSpecs(msDim1) = 1 Then
            ' Row vector; fill accordingly
            workVt(iter, iter) = vec(mSpecs(msLB1), mSpecs(msLB2) - 1 + iter)
        Else
            ' Column vector; fill accordingly
            workVt(iter, iter) = vec(mSpecs(msLB1) - 1 + iter, mSpecs(msLB2))
        End If
    Next iter
    
    ' Return the result
    mDiag = workVt
    
End Function

Public Function mReshape(ByVal arr As Variant, newRows As Long, _
                        newCols As Long) As Variant
    ' Change the shape of a 2-D array. The new shape must
    '  have the same total number of elements as the old.
    ' Input and output element ordering is row-major.
    '
    ' Raises RTE #13 (type mismatch) on a dimension mismatch
    
    Dim workVt As Variant, inVt As Variant, wsf As WorksheetFunction
    Dim iter As Long, iter2 As Long
    Dim mSpecs As Scripting.Dictionary
    
    ' Must be an input array
    inVt = matrixify(arr)
    assertIsArray inVt
    
    ' Must be 1-D or 2-D
    assertIs1Or2D inVt
    
    ' New size dimensions must be positive
    assertPositive newRows
    assertPositive newCols
    
    ' Store the dimension info and bind the worksheet function obj
    Set mSpecs = mtxSpecs(inVt)
    Set wsf = Application.WorksheetFunction
    
    ' Handle the two different dimensionality cases separately
    If mSpecs(msDim2) = 0 Then
        ' 1-D -- Dimensions must be compatible
        If (mSpecs(msUB1) - mSpecs(msLB1) + 1) <> (newRows * newCols) Then
            Err.Raise Number:=13, Description:="Incompatible resize dimensions"
        End If
        
        ' Redim and fill
        ReDim workVt(1 To newRows, 1 To newCols)
        For iter = 0 To (newCols * newRows - 1)
            workVt(wsf.Floor(iter / newCols, 1) + 1, (iter Mod newCols) + 1) = _
                                inVt(mSpecs(msLB1) + iter)
        Next iter
    Else
        ' 2-D -- Dimensions must be compatible
        If ((mSpecs(msUB1) - mSpecs(msLB1) + 1) * _
            (mSpecs(msUB2) - mSpecs(msLB2) + 1)) <> (newRows * newCols) Then
            Err.Raise Number:=13, Description:="Incompatible resize dimensions"
        End If
        
        ' Redim and fill
        ReDim workVt(1 To newRows, 1 To newCols)
        For iter = 0 To (newCols * newRows - 1)
            workVt(wsf.Floor(iter / newCols, 1) + 1, (iter Mod newCols) + 1) = _
                    inVt(wsf.Floor(iter / mSpecs(msDim2), 1) + 1, (iter Mod mSpecs(msDim2)) + 1)
        Next iter
    End If
    
    ' Store the return array
    mReshape = workVt
    
End Function

Public Function mTile(ByVal mtx As Variant, ByVal repVert As Long, _
                                            ByVal repHoriz As Long) As Variant
    ' Tile-repeat copies of the 2-D input matrix the indicated number of times
    '
    ' This could probably be economized by clustering some stacking depending
    '  on the particular numbers of repeats requested
    
    Dim iter As Long
    Dim workVt As Variant, midVt As Variant
    
    ' Initialize the working Variant
    workVt = matrixify(mtx)
    
    ' Assert the input is an array and is 2-D
    assertIsArray workVt
    assertIs2D workVt
    
    ' Replicate parameters must be positive
    assertPositive repVert
    assertPositive repHoriz
    
    ' Horizontal stacks
    For iter = 1 To (repHoriz - 1)
        workVt = mStackHoriz(workVt, mtx)
    Next iter
    
    ' Store the horiz-stacked arrray
    midVt = workVt
    
    ' Vertical stacks
    For iter = 1 To (repVert - 1)
        workVt = mStackVert(workVt, midVt)
    Next iter
    
    ' Store the return value
    mTile = workVt
    
End Function

Public Function mExpand(ByVal mtx As Variant, ByVal expRows As Long, _
                                            ByVal expCols As Long) As Variant
    ' Expand each element of the input matrix into a 'vert x horiz' submatrix
    '  of the output
    
    Dim iterCol As Long, iterRow As Long
    Dim repIterCol As Long, repIterRow As Long
    Dim workVt As Variant
    Dim mSpecs As Scripting.Dictionary
    
    ' Assert 2-D array
    mtx = matrixify(mtx)
    assertIsArray mtx
    assertIs2D mtx
    
    ' Expansion values must be positive
    assertPositive expRows
    assertPositive expCols
    
    ' Store matrix dimension properties
    Set mSpecs = mtxSpecs(mtx)
    
    ' Dimension the new array
    ReDim workVt(1 To expRows * mSpecs(msDim1), 1 To expCols * mSpecs(msDim2))
    
    ' Iterate over the original matrix
    For iterRow = 1 To mSpecs(msDim1)
        For iterCol = 1 To mSpecs(msDim2)
            ' Replicate each entry the indicated number of times into the output
            ' array
            For repIterRow = 1 To expRows
                For repIterCol = 1 To expCols
                    workVt((iterRow - 1) * expRows + repIterRow, _
                                (iterCol - 1) * expCols + repIterCol) = _
                            mtx(mSpecs(msLB1) - 1 + iterRow, mSpecs(msLB2) - 1 + iterCol)
                Next repIterCol
            Next repIterRow
        Next iterCol
    Next iterRow
    
    ' Store the return value
    mExpand = workVt
    

End Function

Public Function matrixify(ByVal item As Variant) As Variant
    ' Wrapper for converting a possible Range input to a matrix
    '  Ranges with more than one array will return Empty
    ' Will also coerce single numeric or string inputs to a 1x1 matrix
    ' Other object types will return Empty
    
    Dim workVt As Variant
    
    If IsObject(item) Then
        If TypeOf item Is Range Then
            If item.Areas.Count = 1 Then
                ' The Value2 property returns the range contents
                '  as an Array
                matrixify = item.Value2
                If Not IsArray(matrixify) Then
                    ' Excel finds only a single value and returns
                    '  as the bare value. Wrap in an array.
                    ReDim workVt(1 To 1, 1 To 1)
                    workVt(1, 1) = item
                    matrixify = workVt
                End If
            Else
                matrixify = Empty
            End If
        Else
            matrixify = Empty
        End If
    ElseIf IsArray(item) Then
        matrixify = item
    Else
        ReDim workVt(1 To 1, 1 To 1)
        workVt(1, 1) = item
        matrixify = workVt
    End If
End Function

Public Function arrRank(ByVal arr As Variant) As Long
    ' Return the rank (number of dimensions) of an input array.
    '
    ' Raises RTE #13 (type mismatch) if `arr` is not actually an Array
    
    Dim iter As Long, dummyVal As Long
    
    ' Must be an array
    assertIsArray arr
    
    ' Initialize the iterator so the pre-increment starts at one
    iter = 0
    
    ' Turn off exception handling
    On Error Resume Next
    
    ' Loop until an error occurs
    Do
        iter = iter + 1
        dummyVal = UBound(arr, iter)
    Loop Until Err.Number <> 0
    
    ' Reset error handling
    Err.Clear
    On Error GoTo 0
    
    ' Desired value will be one less than where the error occurs
    arrRank = iter - 1
    
End Function

Public Function identityMatrix(ByVal length As Long) As Variant
    ' Diagonal matrix of all ones; 'length' must be positive
    assertPositive length
    identityMatrix = mDiag(identityVector(length))
    
End Function

Public Function identityVector(ByVal length As Long) As Variant
    ' Column vector of all ones
    
    Dim workVt As Variant
    Dim iter As Long
    
    ' 'length' must be positive
    assertPositive length
    
    ReDim workVt(1 To length, 1 To 1)
    
    For iter = 1 To length
        workVt(iter, 1) = 1#
    Next iter
    
    identityVector = workVt
    
End Function

Public Function mCol(ByVal Matrix As Variant, ByVal colIndex As Long) As Variant
    Dim iter As Long, workVt As Variant
    Dim mSpecs As Scripting.Dictionary
    
    ' No need to handle bad index explicitly; standard VBA error will be thrown
    
    ' Matrixify input; complain if not a 2-D array
    Matrix = matrixify(Matrix)
    assertIsArray Matrix
    assertIs2D Matrix
    
    ' Pull dimensions
    Set mSpecs = mtxSpecs(Matrix)
    
    ' Column index must be valid
    assertBetween colIndex, mSpecs(msLB2), mSpecs(msUB2), True
    
    ' Redim the work variant and pull out the desired column
    ReDim workVt(1 To mSpecs(msDim1), 1 To 1)
    For iter = 1 To mSpecs(msDim1)
        workVt(iter, 1) = Matrix(mSpecs(msLB1) + iter - 1, colIndex)
    Next iter
    
    ' Store the return value
    mCol = workVt
    
End Function

Public Function mRow(ByVal Matrix As Variant, ByVal rowIndex As Long) As Variant
    Dim iter As Long, workVt As Variant
    Dim mSpecs As Scripting.Dictionary
    
    ' No need to handle bad index explicitly; standard VBA error will be thrown
    
    ' Matrixify input; complain if not a 2-D array
    Matrix = matrixify(Matrix)
    assertIsArray Matrix
    assertIs2D Matrix
    
    ' Pull dimensions
    Set mSpecs = mtxSpecs(Matrix)
    
    ' Row index must be valid
    assertBetween rowIndex, mSpecs(msLB1), mSpecs(msUB1), True
    
    ' Resize the output variant and fill the desired row
    ReDim workVt(1 To 1, 1 To mSpecs(msDim2))
    For iter = 1 To mSpecs(msUB2)
        workVt(1, iter) = Matrix(rowIndex, iter)
    Next iter
    
    mRow = workVt
    
End Function

Public Function mStackHoriz(ByVal mtx1 As Variant, ByVal mtx2 As Variant) As Variant
    ' Stack mtx1 to the left of mtx2. Number of rows must match.
    ' Likely could speed this up for large matrices by just seeding workVt
    '  with mtx1 and doing a ReDim Preserve...
    
    Dim iterCol As Long, iterRow As Long
    Dim workVt As Variant
    Dim mSpecs1 As Scripting.Dictionary, mSpecs2 As Scripting.Dictionary
    
    ' Matrixify inputs; complain if either is not an array
    mtx1 = matrixify(mtx1)
    assertIsArray mtx1
    
    mtx2 = matrixify(mtx2)
    assertIsArray mtx2
    
    ' Insist that both matrices are 2-D (for now, at least)
    assertIs2D mtx1
    assertIs2D mtx2
    
    ' Pull the dimensions on both
    Set mSpecs1 = mtxSpecs(mtx1)
    Set mSpecs2 = mtxSpecs(mtx2)
    
    ' Check for row count match between matrices to be concatenated
    If mSpecs1(msDim1) <> mSpecs2(msDim1) Then
        Err.Raise Number:=9, _
                Description:="Subscript out of bounds: Matrix row count mismatch"
    End If
    
    ' Resize the output matrix to contain both input matrices
    ReDim workVt(1 To mSpecs1(msDim1), 1 To (mSpecs1(msDim2) + mSpecs2(msDim2)))
    
    ' Populate the output matrix
    For iterCol = 1 To UBound(workVt, 2)       ' Columns outer
        For iterRow = 1 To UBound(workVt, 1)   ' Rows inner
            If iterCol <= mSpecs1(msDim2) Then
                ' First matrix data
                workVt(iterRow, iterCol) = _
                        mtx1(iterRow - 1 + mSpecs1(msLB1), iterCol - 1 + mSpecs1(msLB2))
            Else
                ' Second matrix data
                workVt(iterRow, iterCol) = _
                        mtx2(iterRow - 1 + mSpecs2(msLB1), _
                                iterCol - 1 - mSpecs1(msDim2) + mSpecs2(msLB2))
            End If
        Next iterRow
    Next iterCol
    
    ' Set the return value
    mStackHoriz = workVt
    
End Function

Public Function mStackVert(ByVal mtx1 As Variant, ByVal mtx2 As Variant) As Variant
    ' Stack mtx1 atop mtx2. Number of columns must match
    ' Likely could speed this up for large matrices by just seeding workVt
    '  with mtx1 and doing a ReDim Preserve...
    
    Dim iterCol As Long, iterRow As Long
    Dim workVt As Variant
    Dim mSpecs1 As Scripting.Dictionary, mSpecs2 As Scripting.Dictionary
    
    ' Matrixify inputs; complain if either is not an array
    mtx1 = matrixify(mtx1)
    assertIsArray mtx1
    
    mtx2 = matrixify(mtx2)
    assertIsArray mtx2
    
    ' Insist that both matrices are 2-D (for now, at least)
    assertIs2D mtx1
    assertIs2D mtx2
    
    ' Pull the dimensions on both
    Set mSpecs1 = mtxSpecs(mtx1)
    Set mSpecs2 = mtxSpecs(mtx2)
    
    ' Check for column count match between matrices to be concatenated
    If mSpecs1(msDim2) <> mSpecs2(msDim2) Then
        Err.Raise Number:=9, _
                Description:="Subscript out of bounds: Matrix column count mismatch"
    End If
    
    ' Resize the output matrix to contain both input matrices
    ReDim workVt(1 To (mSpecs1(msDim1) + mSpecs2(msDim1)), 1 To mSpecs1(msDim2))
    
    ' Populate the output matrix
    For iterCol = 1 To UBound(workVt, 2)           ' Columns outer
        For iterRow = 1 To UBound(workVt, 1)      ' Rows inner
            If iterRow <= mSpecs1(msDim1) Then
                ' First matrix data
                workVt(iterRow, iterCol) = _
                        mtx1(iterRow - 1 + mSpecs1(msLB1), iterCol - 1 + mSpecs1(msLB2))
            Else
                ' Second matrix data
                workVt(iterRow, iterCol) = _
                        mtx2(iterRow - 1 - mSpecs1(msDim1) + mSpecs2(msLB1), _
                                iterCol - 1 + mSpecs2(msLB2))
            End If
        Next iterRow
    Next iterCol
    
    ' Store the return value
    mStackVert = workVt
    
End Function

Public Function mTranspose(ByVal mtx As Variant) As Variant
    ' Wrapper around WorksheetFunction.Transpose for the sake of
    '  concision.
    
    Dim wsf As WorksheetFunction
    
    ' Ensure input is a 2-D array
    mtx = matrixify(mtx)
    assertIsArray mtx
    assertIs2D mtx
    
    ' Bind wsf and calculate transpose
    Set wsf = Application.WorksheetFunction
    
    mTranspose = wsf.Transpose(mtx)
    
End Function

Public Function deltaFxn(ByVal val1 As Long, ByVal val2 As Long) As Long
    If val1 = val2 Then
        deltaFxn = 1
    Else
        deltaFxn = 0
    End If
End Function

Public Function ORCADebug(debugActive As Boolean) As Boolean
    ' Utility to allow quick in-sheet switching of debug flag
    ThisWorkbook.DEBUG_FLAG = debugActive
    ORCADebug = debugActive
End Function

Public Function ORCAVolatile(volActive As Boolean) As Boolean
    ' Utility to allow quick in-sheet switch of global Application.Volatile flag
    ThisWorkbook.VOLATILE_FLAG = volActive
    ORCAVolatile = volActive
End Function

Public Sub assertIsArray(vnt As Variant)
    If Not IsArray(vnt) Then
        Err.Raise Number:=13, Description:="Type mismatch: Argument must be an array"
    End If
End Sub

Public Sub assertIs2D(vnt As Variant)
    ' Safest to call this only after 'assertIsArray()'
    If Not arrRank(vnt) = 2 Then
        Err.Raise Number:=13, Description:="Type mismatch: 2-D array required"
    End If
End Sub

Public Sub assertIs1D(vnt As Variant)
    ' Safest to call this only after 'assertIsArray()'
    If Not arrRank(vnt) = 1 Then
        Err.Raise Number:=13, Description:="Type mismatch: 1-D array required"
    End If
End Sub

Public Sub assertIs1Or2D(vnt As Variant)
    ' Safest to call this only after 'assertIsArray()'
    If Not (arrRank(vnt) = 1 Or arrRank(vnt) = 2) Then
        Err.Raise Number:=13, Description:="Type mismatch: 1-D or 2-D array required"
    End If
End Sub
 
Public Sub assertPositive(val As Variant)
    If Not val > 0 Then
        Err.Raise Number:=380, Description:="Invalid property value: Must be positive"
    End If
End Sub

Public Sub assertNegative(val As Variant)
    If Not val < 0 Then
        Err.Raise Number:=380, Description:="Invalid property value: Must be negative"
    End If
End Sub

Public Sub assertNonPositive(val As Variant)
    If Not val <= 0 Then
        Err.Raise Number:=380, Description:="Invalid property value: Must be non-positive"
    End If
End Sub

Public Sub assertNonNegative(val As Variant)
    If Not val >= 0 Then
        Err.Raise Number:=380, Description:="Invalid property value: Must be non-negative"
    End If
End Sub

Public Sub assertBetween(val As Variant, low As Variant, high As Variant, include As Boolean)
    If include Then
        If val < low Or val > high Then
            Err.Raise Number:=380, Description:="Invalid property value: Outside valid range"
        End If
    Else
        If val <= low Or val >= high Then
            Err.Raise Number:=380, Description:="Invalid property value: Outside valid range"
        End If
    End If
End Sub

Public Function dematrixify(var As Variant) As Variant
    ' If 'var' is a singleton array, returns the single element
    '  with the surrounding array character stripped
    ' Otherwise, the input value is returned unmodified.
    '
    ' Will crash if passed an object
    '
    
    If IsArray(var) Then
        Select Case arrRank(var)
        Case 1
            If LBound(var, 1) = UBound(var, 1) Then
                dematrixify = var(LBound(var, 1))
                Exit Function
            End If
        Case 2
            If LBound(var, 1) = UBound(var, 1) And _
                        LBound(var, 2) = UBound(var, 2) Then
                dematrixify = var(LBound(var, 1), LBound(var, 2))
                Exit Function
            End If
        End Select
    End If
    
    ' If not suitable for de-arraying, just return
    dematrixify = var
    
End Function

Public Function mtxSpecs(ByVal mtx As Variant) As Scripting.Dictionary

    ' A zero value for msDim2 indicates a 1-D vector. msLB2 and msUB2
    '  will be stored as -1 in this case.

    Dim dict As New Scripting.Dictionary

    ' Matrixify input; complain if not an array
    mtx = matrixify(mtx)
    If Not IsArray(mtx) Then
        Err.Raise Number:=13, Description:="Not an array"
    End If
    
    ' Complain if not rank two or rank one
    If Not (arrRank(mtx) = 2 Or arrRank(mtx) = 1) Then
        Err.Raise Number:=13, Description:="mtx must be 1-D or 2-D"
    End If
    
    ' Pull dimensions &c.
    ' Always going to be a first dimension
    dict.Add msLB1, LBound(mtx, 1)
    dict.Add msUB1, UBound(mtx, 1)
    dict.Add msDim1, (UBound(mtx, 1) - LBound(mtx, 1) + 1)
    
    ' May not be a second dimension
    If arrRank(mtx) = 2 Then
        ' It's there; just calculate
        dict.Add msLB2, LBound(mtx, 2)
        dict.Add msUB2, UBound(mtx, 2)
        dict.Add msDim2, (UBound(mtx, 2) - LBound(mtx, 2) + 1)
        dict.Add msNumEl, (dict.item(msDim1) * dict.item(msDim2))
    Else
        ' Nope, 1-D
        dict.Add msLB2, -1
        dict.Add msUB2, -1
        dict.Add msDim2, 0
        dict.Add msNumEl, dict.item(msDim1)
    End If
    
    ' Assign the return value
    Set mtxSpecs = dict
    
End Function

Public Function ORCA_Thermo( _
            ByVal outputFile As String, _
            ByVal rotSym As Long, _
            ByVal direction As vectorDirection _
            ) As Variant
    
    ' Function to retrieve thermodynamic parameters from a frequency/thermo ORCA calculation
    '
    ' Function is planned only for use as a worksheet function, so don't worry about
    '  detailed error handling.  String-based should be fine
    '
    ' Return vector elements are:
    '  1  - Temperature
    '  2  - Pressure
    '  3  - Electronic energy
    '  4  - Harmonic ZPE
    '  5  - Vibrational thermal contribution to E
    '  6  - Rotational thermal contribution to E
    '  7  - Translational thermal contribution to E
    '  8  - Ideal-gas (kB*T) enthalpy factor
    '  9  - Electronic T*S
    '  10 - Vibrational T*S
    '  11 - Rotational T*S (corrected according to rotSym parameter)
    '  12 - Translational T*S
    '
    
    Dim rx As New RegExp, wsf As WorksheetFunction, mch As Match
    Dim tStrm As TextStream, fileText As String
    Dim str As String, str2 As String
    Dim outVt As Variant
    Dim iter As Long
    Dim fs As FileSystemObject
    Const numEls As Long = 12
    Const notFoundStr As String = "NF"
    
    Const gasConst As Double = 3.1647141251652E-06    ' Eh / K
    
    ' Drop to catch-all error reporter
    'On Error GoTo VBA_Error_Exit
    
    ' Assign the worksheet function object
    Set wsf = Application.WorksheetFunction
    
    ' Default 'nothing happened' return value
    ORCA_Thermo = "No return value set"
    
    ' Re-dimension the output variant as a column vector; will transpose before
    '  function return if row vector is requested
    ReDim outVt(1 To numEls, 1 To 1)
    
    ' Catch the special "Labels" input string
    If UCase(outputFile) = "LABELS" Then
        outVt(1, 1) = "T (K)"
        outVt(2, 1) = "P (atm)"
        outVt(3, 1) = "E_elec"
        outVt(4, 1) = "E_ZPE"
        outVt(5, 1) = "E_th,vib"
        outVt(6, 1) = "E_th,rot"
        outVt(7, 1) = "E_th,tr"
        outVt(8, 1) = "k_B*T"
        outVt(9, 1) = "T*S_el"
        outVt(10, 1) = "T*S_vib"
        outVt(11, 1) = "T*S_rot"
        outVt(12, 1) = "T*S_tr"
        
        Select Case direction
        Case vdRowVector
            ORCA_Thermo = wsf.Transpose(outVt)
        Case vdColVector
            ORCA_Thermo = outVt
        End Select
        
        Exit Function
    End If
    
    ' Bind filesystem object
    Set fs = CreateObject("Scripting.FileSystemObject")
    
    ' Check that indicated file exists
    If Not fs.FileExists(outputFile) Then
        ORCA_Thermo = "File not found"
        Exit Function
    End If
    
    ' Open file, pull contents, and close
    Set tStrm = fs.OpenTextFile(outputFile, ForReading, False, TristateFalse)
    fileText = tStrm.ReadAll
    tStrm.Close
  
    With rx
        ' Build the Regex to capture everything from the
        '  thermodynamics section, to the end of the file.
        .MultiLine = False
        .Global = False
        .IgnoreCase = True
        .Pattern = "[-]+\s*\n\s*THERMOCHEMISTRY([^\n]|\n)*"
        If Not .Test(fileText) Then
            ORCA_Thermo = "Thermo section not found"
            Exit Function
        End If
        str = .Execute(fileText)(0).Value
        
        ' Retrieve the needed pieces of output and add to the vector
        ' TEMPERATURE
        .Pattern = "temperature[^.]+\.+[^0-9]*([0-9.]+)\s+K"
        If Not .Test(str) Then
            'ORCA_Thermo = "Simulation temperature not found"
            'Exit Function
            outVt(1, 1) = notFoundStr
        Else
            'Set mch = .Execute(str)(0)
            outVt(1, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' PRESSURE
        .Pattern = "pressure[^.]+\.+[^0-9]*([0-9.]+)\s+atm"
        If Not .Test(str) Then
            'ORCA_Thermo = "Simulation pressure not found"
            'Exit Function
            outVt(2, 1) = notFoundStr
        Else
            'Set mch = .Execute(str)(0)
            outVt(2, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ELECTRONIC ENERGY
        .Pattern = "electronic energy[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            'ORCA_Thermo = "Electronic energy not found"
            'Exit Function
            outVt(3, 1) = notFoundStr
        Else
            'Set mch = .Execute(str)(0)
            outVt(3, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ZERO-POINT ENERGY
        .Pattern = "zero point energy[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(4, 1) = notFoundStr
        Else
            outVt(4, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' VIBRATIONAL THERMAL CORRECTION
        .Pattern = "thermal vibrational correction[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(5, 1) = notFoundStr
        Else
            outVt(5, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ROTATIONAL THERMAL CORRECTION
        .Pattern = "thermal rotational correction[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(6, 1) = notFoundStr
        Else
            outVt(6, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' TRANSLATIONAL THERMAL CORRECTION
        .Pattern = "thermal translational correction[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(7, 1) = notFoundStr
        Else
            outVt(7, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' IDEAL-GAS ENTHALPY CORRECTION
        .Pattern = "thermal enthalpy correction [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(8, 1) = notFoundStr
        Else
            outVt(8, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ELECTRONIC ENTROPY
        .Pattern = "electronic entropy [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(9, 1) = notFoundStr
        Else
            outVt(9, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' VIBRATIONAL ENTROPY
        .Pattern = "vibrational entropy [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(10, 1) = notFoundStr
        Else
            outVt(10, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ROTATIONAL ENTROPY
        .Pattern = "thermal rotational correction [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            ' Don't bother calculating this if there was a glitch in
            '  the automated rotational entropy calculation
            outVt(11, 1) = notFoundStr
        Else
            ' Must retrieve the rotational partition function and compute new
            '  entropy value
            .Pattern = "\s+qrot =\s*([0-9.]+)\s*\n"
            outVt(11, 1) = gasConst * ( _
                    wsf.Ln(CDbl(.Execute(str)(0).SubMatches(0)) / CDbl(rotSym)) + 1.5 _
                    ) * outVt(1, 1)
        End If
        
        ' TRANSLATIONAL ENTROPY
        .Pattern = "translational entropy [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(12, 1) = notFoundStr
        Else
            outVt(12, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
    End With
    
    ' Store the resulting vector in the appropriate orientation
    Select Case direction
    Case vdColVector
        ORCA_Thermo = outVt
    Case vdRowVector
        ORCA_Thermo = wsf.Transpose(outVt)
    End Select
    
    
    Exit Function
    
VBA_Error_Exit:
    ORCA_Thermo = "VBA error"
    Exit Function
    
End Function

