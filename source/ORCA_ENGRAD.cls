VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ORCA_ENGRAD"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
'-------------------------------------------------------------------------------
' Name:        ORCA_ENGRAD (Class Module)
' Purpose:     Handles imports for ORCA .engrad files
'
' Author:      Brian Skinn
'                bskinn@alum.mit.edu
'
' Created:     30 Apr 2016
' Copyright:   (c) Brian Skinn 2016
' License:     The MIT License; see "license.txt" for full license terms
'                   and contributor agreement.
'
'       This file is part of ORCA Importer, an Excel VBA add-in providing
'       memoized import functionality for output generated by the ORCA
'       quantum chemistry software program package
'       (http://orcaforum.cec.mpg.de).
'
'       http://www.github.com/bskinn/excel-orcaimport
'
'-------------------------------------------------------------------------------

Option Explicit
Option Base 1

' Container for data imported from an ORCA ENGRAD file
' Includes variables for the displaced mode, direction, and magnitude using
'  common Enum types
'
' Object not to be modified after creation; constructor routine to populate all internal
'  variables from ENGRAD file at indicated path
'
' THE DISPLACEMENT MAGNITUDE IS ALWAYS POSITIVE, if DispDir is not dispNone. The
'  DispDirection Enum is defined such that the signed displacement can be obtained
'  by: DispDir * DispMag

Private NumAtoms As Long, Energy As Double
Private Gradient As Variant, AtomicNums As Variant, AtomCoords As Variant
Private ErrorStr As String
Private Initialized As Boolean
Private wsf As WorksheetFunction



'  ===  CONSTRUCTOR  ===
Public Sub readENGRAD(ByVal ENGRAD_Path As String, ByRef fso As FileSystemObject)
    ' No internal error handling for, e.g., IO errors &c.
    
    Dim rx As New RegExp, ts As TextStream
    Dim str As String, str2 As String
    Dim iter As Long, mchs As MatchCollection, val As Long
    
    ' Only proceed if object hasn't already been configured
    If Initialized Then
        Err.Raise Number:=425, Description:="ORCA_ENGRAD object already initialized"
    End If
    
    ' Bind the filesystem
    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' Open the ENGRAD file for reading (no error checks)
    Set ts = fso.OpenTextFile(ENGRAD_Path, ForReading)
    
    ' Pull ENGRAD file contents
    str = ts.ReadAll
    
    With rx
        ' Configure RegExp
        .Global = True
        .MultiLine = False
        .IgnoreCase = True
        
        ' == NUMBER OF ATOMS ==
        ' Grab portion of file with number of atoms info, test, then store value
        .Pattern = "#.*Number of atoms.*\n#.*\n[^0-9]*([0-9]+).*\n#"
        If .Test(str) Then
            NumAtoms = CLng(.Execute(str).item(0).SubMatches(0))
        Else
            ErrorStr = "Number of atoms specification not found"
            Exit Sub
        End If
        
        ' == TOTAL ENERGY ==
        ' Grab file portion, test, store value
        .Pattern = "#.*current total energy in eh.*\n#.*\n\s*([-]?[0-9]+\.[0-9]+).*\n#"
        If .Test(str) Then
            Energy = CDbl(.Execute(str).item(0).SubMatches(0))
        Else
            ErrorStr = "Electronic energy value not found"
            Exit Sub
        End If
        
        
        ' == GRADIENT ==
        ' Pattern to find the gradient region
        .Pattern = "in Eh/bohr.*\n#.*\n(\s+[0-9.-]+.*\n)+"
        
        ' Retrieve the entire found pattern for subsequent internal searching
        If Not .Test(str) Then
            ' Gradient portion of file not found
            ErrorStr = "Gradient block not found"
            Exit Sub
        End If
        
        ' Retrieve just the gradient region
        str2 = .Execute(str).item(0)
        
        ' Reset the pattern to find the individual decimal values
        '  ASSUMES NO SCIENTIFIC NOTATION!  Valid for ENGRAD files a/o v3.0.1 & v3.0.2
        .Pattern = "[0-9.-]+"
        
        ' Store the series of matched values
        ' No .Test checking required -- if prior pattern matched, then at least
        '  one value of a reasonable form was found.
        Set mchs = .Execute(str2)
        
        ' Consistency check on the number of gradient entries -- should be
        '  3*NumAtoms
        If Not mchs.Count = 3 * NumAtoms Then
            ErrorStr = "Number of gradient elements inconsistent with number of atoms"
            Exit Sub
        End If
        
        ' Size the internal gradient array according to the number of values
        '  found
        ReDim Gradient(1 To mchs.Count, 1 To 1)
        
        ' Populate the internal array
        For iter = 1 To mchs.Count
            Gradient(iter, 1) = CDbl(mchs.item(iter - 1))
        Next iter
        
        ' == ATOMIC NUMBERS AND COORDINATES ==
        ' Pattern to find the atoms & coordinates block
        .Pattern = "atomic numbers and current coordinates in bohr.*\n#.*\n" & _
                "(\s+[0-9]+(\s+[0-9.-]+){3}.*\n)+"
        
        ' Retrieve entire pattern found for subsequent parsing, after .Test
        If Not .Test(str) Then
            ' Atoms and coordinates portion of file not found
            ErrorStr = "Atomic numbers and coordinates could not be found " & _
                    "in the indicated file"
            Exit Sub
        End If
        
        str2 = .Execute(str).item(0)
        
        ' Reset pattern to find atomic numbers and set matches
        .Pattern = "\n[^0-9]+([0-9]+)"
        Set mchs = .Execute(str2)
        
        ' Confirm number of atoms found matches that expected from above
        If Not mchs.Count = NumAtoms Then
            ErrorStr = "Mismatch between 'number of atoms' specification and " & _
                    "number of atoms found in coordinates block"
            Exit Sub
        End If
        
        ' Dim the array for the atomic numbers and store, checking for invalid
        '  specifiers
        ReDim AtomicNums(1 To mchs.Count, 1 To 1)
        For iter = 1 To mchs.Count
            val = CLng(mchs.item(iter - 1).SubMatches(0))
            If val > Max_Atomic_Num Or val < Min_Atomic_Num Then
                ErrorStr = "Invalid atomic number """ & val & """ found in " & _
                        "coordinates block"
                Exit Sub
            Else
                AtomicNums(iter, 1) = CLng(val)
            End If
        Next iter
        
        ' Reset pattern to find coordinates and execute
        .Pattern = "[-]?[0-9]+\.[0-9]+"
        Set mchs = .Execute(str2)
        
        ' Confirm that the number of coordinates is 3*NumAtoms
        If Not mchs.Count = 3 * NumAtoms Then
            ErrorStr = "Mismatch between 'number of atoms' specification and " & _
                    "number of coordinate values found in coordinates block"
            Exit Sub
        End If
        
        ' Resize the coordinates array and store the values
        ReDim AtomCoords(1 To mchs.Count, 1 To 1)
        For iter = 1 To mchs.Count
            AtomCoords(iter, 1) = CDbl(mchs.item(iter - 1))
        Next iter
        
    End With
    
    ' Set the initialized flag
    Initialized = True
    
End Sub


Private Sub RaiseUninitError()
    Err.Raise Number:=425, Description:="Cannot use improperly " & _
                                    "initialized ORCA_ENGRAD object"
End Sub

' ===  PROPERTY GET  ===
Property Get gradientArray() As Variant
    If ErrorStr <> "" Then
        gradientArray = ErrorStr
    Else
        If Initialized Then
            gradientArray = Gradient
        Else
            RaiseUninitError
        End If
    End If
End Property

Property Get atomicNumsArray() As Variant
    If ErrorStr <> "" Then
        atomicNumsArray = ErrorStr
    Else
        If Initialized Then
            atomicNumsArray = AtomicNums
        Else
            RaiseUninitError
        End If
    End If
End Property

Property Get atomicSymsArray() As Variant
    
    Dim iter As Long, workVnt As Variant
    
    If ErrorStr <> "" Then
        ' Error occurred; report the string
        atomicSymsArray = ErrorStr
    Else
        If Initialized Then
            ' Resize the working array
            ReDim workVnt(1 To NumAtoms, 1 To 1)
            
            ' Iterate to generate the resulting symbols array
            For iter = 1 To NumAtoms
                workVnt(iter, 1) = atomSym(CLng(AtomicNums(iter, 1)))
            Next iter
            
            ' Store the return value
            atomicSymsArray = workVnt
        Else
            RaiseUninitError
        End If
    End If
    
End Property

Property Get expandedAtomicNumsArray() As Variant
    
    Dim iter As Long, workVnt As Variant
    
    If ErrorStr <> "" Then
        expandedAtomicNumsArray = ErrorStr
    Else
        If Initialized Then
            ' Resize the working array
            ReDim workVnt(1 To NumAtoms * 3, 1 To 1)
            
            If Not wsf.IsText(AtomicNums) Then
                ' Ok to fill
                For iter = 1 To NumAtoms
                    workVnt(3 * (iter - 1) + 1, 1) = AtomicNums(iter, 1)
                    workVnt(3 * (iter - 1) + 2, 1) = AtomicNums(iter, 1)
                    workVnt(3 * (iter - 1) + 3, 1) = AtomicNums(iter, 1)
                Next iter
            Else
                ' Error occurred; pass 'reason' string through
                workVnt(1, 1) = AtomicNums
            End If
            
            ' Store the return value
            expandedAtomicNumsArray = workVnt
        Else
            RaiseUninitError
        End If
    End If
    
End Property

Property Get expandedAtomicSymsArray() As Variant
    
    Dim iter As Long, workVnt As Variant
    
    If ErrorStr <> "" Then
        expandedAtomicSymsArray = ErrorStr
    Else
        If Initialized Then
            ' Resize the working array
            ReDim workVnt(1 To NumAtoms * 3, 1 To 1)
            
            If Not wsf.IsText(AtomicNums) Then
                ' Ok to populate
                For iter = 1 To NumAtoms
                    workVnt(3 * (iter - 1) + 1, 1) = atomSym(CLng(AtomicNums(iter, 1)))
                    workVnt(3 * (iter - 1) + 2, 1) = atomSym(CLng(AtomicNums(iter, 1)))
                    workVnt(3 * (iter - 1) + 3, 1) = atomSym(CLng(AtomicNums(iter, 1)))
                Next iter
                expandedAtomicSymsArray = workVnt
            Else
                ' Error occurred; pass 'reason' string through
                workVnt(1, 1) = AtomicNums
            End If
            
            ' Store return value
            expandedAtomicSymsArray = workVnt
        Else
            RaiseUninitError
        End If
    End If
    
End Property

Property Get atomCoordsArray() As Variant
    If ErrorStr <> "" Then
        atomCoordsArray = ErrorStr
    Else
        If Initialized Then
            atomCoordsArray = AtomCoords
        Else
            RaiseUninitError
        End If
    End If
End Property

Property Get numOfAtoms() As Variant
    If ErrorStr <> "" Then
        numOfAtoms = ErrorStr
    Else
        If Initialized Then
            numOfAtoms = NumAtoms
        Else
            RaiseUninitError
        End If
    End If
End Property

Property Get totalEnergy() As Variant
    If ErrorStr <> "" Then
        totalEnergy = ErrorStr
    Else
        If Initialized Then
            totalEnergy = Energy
        Else
            RaiseUninitError
        End If
    End If
End Property

Property Get isInitialized() As Boolean
    isInitialized = Initialized
End Property


' ===  CLASS EVENTS  ===

Private Sub Class_Initialize()
    ' Probably not necessary to include explicitly, but can't hurt
    Initialized = False
    ErrorStr = ""
    
    ' Bind the wsf object for ready access
    Set wsf = Application.WorksheetFunction
End Sub
