VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ORCA_XYZ"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
'-------------------------------------------------------------------------------
' Name:        ORCA_XYZ (Class Module)
' Purpose:     Handles imports for ORCA .xyz and .trj (OpenBabel) files
'
' Author:      Brian Skinn
'                bskinn@alum.mit.edu
'
' Created:     30 Apr 2016
' Copyright:   (c) Brian Skinn 2016
' License:     The MIT License; see "license.txt" for full license terms
'                   and contributor agreement.
'
'       This file is part of ORCA Importer, an Excel VBA add-in providing
'       memoized import functionality for output generated by the ORCA
'       quantum chemistry software program package
'       (http://orcaforum.cec.mpg.de).
'
'       http://www.github.com/bskinn/excel-orcaimport
'
'-------------------------------------------------------------------------------

Option Explicit
Option Base 1

' Container for data imported from an ORCA XYZ or TRJ file
'
' Should actually work for any file in the standard XYZ format where
'  the number of atoms remains constant through the whole file
'
' Object not to be modified after creation; constructor routine to populate all internal
'  variables from HESS file at indicated path, and input parameters
'
' UNITS ARE IN AMU AND BOHRS
'
' THE DISPLACEMENT MAGNITUDE IS ALWAYS POSITIVE, if DispDir is not dispNone. The
'  DispDirection Enum is defined such that the signed displacement can be obtained
'  by: DispDir * DispMag

' Want to pull Hessian, frequencies, normal modes, atoms/masses, geometry from .HESS
'  If present, also retrieve the eigenvalues/-vectors?  Mainly only useful as a cross-check,
'  probably?


Private NumAtoms As Long, NumGeoms As Long, Comments As Variant
Private AtomicNums As Variant, AtomCoords As Variant
Private Initialized As Boolean



'  ===  CONSTRUCTOR  ===
Public Function readXYZ( _
            ByVal XYZ_Path As String, _
            ByRef fso As FileSystemObject _
            ) As String
    ' Null string return means file indicated by pathStr exists and conforms to expected pattern,
    '  and that the data was retrieved successfully.
    ' Non-null string contains description of error encountered.
    
    Dim rx As New RegExp, ts As TextStream
    Dim str As String, str2 As String
    Dim iter As Long, iter2 As Long, iter3 As Long
    Dim mch As Match, mchs As MatchCollection, mchs2 As MatchCollection
    Dim val As Long, val2 As Long
    Dim valStr As String
    
    ' Debug mode
    If DEBUG__MODE__ Then
        On Error GoTo 0
    Else
        On Error GoTo VBA_Error_Exit
    End If
    
    ' Initialize return value
    readXYZ = "Constructor exited without specifying return value"
    
    ' Only proceed if object hasn't already been configured
    If Initialized Then
        readXYZ = "Object has already been initialized"
        GoTo Error_Exit
    End If
    
    ' Bind the filesystem
    If fso Is Nothing Then Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' Open the XYZ file for reading
    If fso.FileExists(XYZ_Path) Then
        Set ts = fso.OpenTextFile(XYZ_Path, ForReading)
    Else
        readXYZ = "Specified file not found"
        GoTo Error_Exit
    End If
    
    ' Pull entire file contents
    str = ts.ReadAll
    
    With rx
        .Global = True
        .IgnoreCase = True
        .MultiLine = False
        
        ' == GEOMETRIES ==
        ' This does not check for badly malformed OpenBabel XYZ files, where content exists that is
        '  improperly structured to the point that the geometry block RegExp does not retrieve it.
        '  It will find all properly formatted geometry blocks, and will return an error: (1) if the wrong
        '  number of coordinates is provided within a properly formatted block; (2) if not all of the
        '  properly formatted blocks have the same number of atoms; (3) if no properly formatted blocks
        '  are found; (4) if atoms collide in a given geometry; (5)...
        .Pattern = "([0-9]+)\s*\n(.*)\n((\s+[a-zA-Z]+(\s+[0-9.-]+){3}\s*\n)+)"
        
        If Not .Test(str) Then
            ' No geometries found
            readXYZ = "Atom geometry data not found in indicated file"
            GoTo Error_Exit
        End If
        
        ' Store the matches
        Set mchs = .Execute(str)
        
        ' Store relevant values and dimension the various arrays
        NumAtoms = CLng(mchs(0).SubMatches(0))
        NumGeoms = mchs.Count
        ReDim Comments(1 To NumGeoms, 1 To 1)
        Comments(1, 1) = mchs(0).SubMatches(1)
        ReDim AtomicNums(1 To NumAtoms, 1 To 1)
        ReDim AtomCoords(1 To NumAtoms * 3, 1 To NumGeoms) ' column vectors of atom positions
        
        ' Loop to check that the number of atoms is the same as the first geom, and to store
        '  the comments
        If NumGeoms > 1 Then
            For iter = 2 To NumGeoms
                Comments(iter, 1) = mchs(iter - 1).SubMatches(1)
                If Not CLng(mchs(iter - 1).SubMatches(0)) = NumAtoms Then
                    readXYZ = "Mismatch in 'number of atoms' specification at geometry #" & iter
                    GoTo Error_Exit
                End If
            Next iter
        End If
        
        ' Reprocess the coordinates of each match to retrieve the atom and coordinate information
        '  The pass on the first geometry (defining values) is different than the rest (proofing values)
        .Pattern = "\s+([a-zA-Z]+)\s+([0-9.-]+)\s+([0-9.-]+)\s+([0-9.-]+)\s*\n"
        
        ' Loop and retrieve geometries
        For iter = 1 To mchs.Count
            ' Check to ensure coordinate data actually present
            If Not .Test(mchs(iter - 1).SubMatches(2)) Then
                ' This should never occur, as the pattern is chosen to succeed on any of mchs
                readXYZ = "Coordinate data not found when parsing geometry block #" & iter
                GoTo Error_Exit
            End If
            
            ' Pull atom symbols and coordinates as Matches
            Set mchs2 = .Execute(mchs(iter - 1).SubMatches(2))
            
            ' Confirm number of atoms actually found is correct
            If Not NumAtoms = mchs2.Count Then
                readXYZ = "Incorrect number of atoms found when parsing geometry block #" & iter
                GoTo Error_Exit
            End If
            
            For iter2 = 1 To mchs2.Count  ' Loop over each atom
                ' For the first geometry, proof and store the atomic number.
                '  For all later geometries, confirm consistency
                valStr = mchs2.item(iter2 - 1).SubMatches(0)
                If iter = 1 Then
                    ' Check validity in first block (element is simulable) and store
                    If atomNum(valStr) = Invalid_Atom_Symbol Then
                        readXYZ = "Invalid atomic symbol """ & valStr & """"
                        GoTo Error_Exit
                    Else
                        AtomicNums(iter2, 1) = CLng(atomNum(valStr))
                    End If
                Else
                    ' Check consistency with value store from first block
                    If Not CLng(atomNum(valStr)) = AtomicNums(iter2, 1) Then
                        readXYZ = "Atomic symbol mismatch in block " & iter & ", atom " & iter2
                        GoTo Error_Exit
                    End If
                End If
                
                ' Loop and store the coordinates, CONVERTING TO BOHRS!
                For iter3 = 1 To 3
                    AtomCoords(3 * (iter2 - 1) + iter3, iter) = CDbl(mchs2(iter2 - 1).SubMatches(iter3)) / Angs_per_Bohr
                Next iter3
            Next iter2
        Next iter
    End With
    
    ' Set the success (null string) return value
    readXYZ = ""
    
    ' Set the initialized flag and exit
    Initialized = True
    On Error GoTo 0
    Exit Function
    
    
Error_Exit:
    readXYZ = "ORCA_XYZ: " & readXYZ
    On Error GoTo 0
    Exit Function
    
VBA_Error_Exit:
    readXYZ = "ORCA_XYZ.readXYZ: VBA Error " & Err.Number & ": " & Err.Description
    Err.Clear
    On Error GoTo 0
    Exit Function
    
End Function


'  ===  PROPERTY GET  ===
Property Get numOfAtoms() As Long
    If Initialized Then
        numOfAtoms = NumAtoms
    Else
        numOfAtoms = Uninit_Unsigned_Long
    End If
End Property

Property Get numOfGeoms() As Long
    If Initialized Then
        numOfGeoms = NumGeoms
    Else
        numOfGeoms = Uninit_Unsigned_Long
    End If
End Property

Property Get isInitialized() As Boolean
    isInitialized = Initialized
End Property

Property Get commentsArray() As Variant
    If Initialized Then
        commentsArray = Comments
    Else
        commentsArray = Empty
    End If
End Property

Property Get atomicNumsArray() As Variant
    If Initialized Then
        atomicNumsArray = AtomicNums
    Else
        atomicNumsArray = Empty
    End If
End Property

Property Get atomicSymsArray() As Variant
    
    Dim iter As Long, workVnt As Variant
    
    ' Debug mode
    If DEBUG__MODE__ Then
        On Error GoTo 0
    Else
        On Error GoTo VBA_Error_Exit
    End If
    
    If Initialized Then
        ReDim workVnt(1 To NumAtoms, 1 To 1)
        For iter = 1 To NumAtoms
            workVnt(iter, 1) = atomSym(CLng(AtomicNums(iter, 1)))
        Next iter
        atomicSymsArray = workVnt
    Else
        atomicSymsArray = Empty
    End If
    
    ' Successful exit
    Exit Property
    
    
Error_Exit:
    atomicSymsArray = "ORCA_XYZ.atomicSymsArray: " & atomicSymsArray
    On Error GoTo 0
    Exit Property
    
VBA_Error_Exit:
    atomicSymsArray = "ORCA_XYZ.atomicSymsArray: VBA Error " & Err.Number & ": " & Err.Description
    Err.Clear
    On Error GoTo 0
    Exit Property
    
End Property

Property Get expandedAtomicNumsArray() As Variant
    
    Dim iter As Long, workVnt As Variant
    
    ' Debug mode
    If DEBUG__MODE__ Then
        On Error GoTo 0
    Else
        On Error GoTo VBA_Error_Exit
    End If
    
    If Initialized Then
        ReDim workVnt(1 To NumAtoms * 3, 1 To 1)
        For iter = 1 To NumAtoms
            workVnt(3 * (iter - 1) + 1, 1) = AtomicNums(iter, 1)
            workVnt(3 * (iter - 1) + 2, 1) = AtomicNums(iter, 1)
            workVnt(3 * (iter - 1) + 3, 1) = AtomicNums(iter, 1)
        Next iter
        expandedAtomicNumsArray = workVnt
    Else
        expandedAtomicNumsArray = Empty
    End If
    
    ' Successful exit
    Exit Property
    
    
Error_Exit:
    expandedAtomicNumsArray = "ORCA_XYZ.expandedAtomicNumsArray: " & expandedAtomicNumsArray
    On Error GoTo 0
    Exit Property
    
VBA_Error_Exit:
    expandedAtomicNumsArray = "ORCA_XYZ.expandedAtomicNumsArray: VBA Error " & Err.Number & ": " & Err.Description
    Err.Clear
    On Error GoTo 0
    Exit Property
    
    
End Property

Property Get expandedAtomicSymsArray() As Variant
    
    Dim iter As Long, workVnt As Variant
    
    ' Debug mode
    If DEBUG__MODE__ Then
        On Error GoTo 0
    Else
        On Error GoTo VBA_Error_Exit
    End If
    
    If Initialized Then
        ReDim workVnt(1 To NumAtoms * 3, 1 To 1)
        For iter = 1 To NumAtoms
            workVnt(3 * (iter - 1) + 1, 1) = atomSym(CLng(AtomicNums(iter, 1)))
            workVnt(3 * (iter - 1) + 2, 1) = atomSym(CLng(AtomicNums(iter, 1)))
            workVnt(3 * (iter - 1) + 3, 1) = atomSym(CLng(AtomicNums(iter, 1)))
        Next iter
        expandedAtomicSymsArray = workVnt
    Else
        expandedAtomicSymsArray = Empty
    End If
    
    ' Successful exit
    Exit Property
    
    
Error_Exit:
    expandedAtomicSymsArray = "ORCA_XYZ.expandedAtomicSymsArray: " & expandedAtomicSymsArray
    On Error GoTo 0
    Exit Property
    
VBA_Error_Exit:
    expandedAtomicSymsArray = "ORCA_XYZ.expandedAtomicSymsArray: VBA Error " & Err.Number & ": " & Err.Description
    Err.Clear
    On Error GoTo 0
    Exit Property
    
End Property

Property Get atomCoordsArray() As Variant
    If Initialized Then
        atomCoordsArray = AtomCoords
    Else
        atomCoordsArray = Empty
    End If
End Property

Property Get singleGeometry( _
            geomNum As Long _
            ) As Variant
    
    Dim iter As Long, workVnt As Variant
    
    ' Debug mode
    If DEBUG__MODE__ Then
        On Error GoTo 0
    Else
        On Error GoTo VBA_Error_Exit
    End If
    
    If Initialized Then
        ' Size working array
        ReDim workVnt(1 To NumAtoms * 3, 1 To 1)
        
        ' Iterate and fill working array
        For iter = 1 To 3 * NumAtoms
            ' If a valid geomNum, fill the geometry
            If geomNum >= 1 And geomNum <= NumGeoms Then
                workVnt(iter, 1) = CDbl(AtomCoords(iter, geomNum))
            Else
                singleGeometry = "Invalid geometry number"
                GoTo Error_Exit
            End If
        Next iter
        
        singleGeometry = workVnt
        
    Else
        singleGeometry = Empty
    End If
    
    On Error GoTo 0
    Exit Property
    
Error_Exit:
    singleGeometry = "ORCA_XYZ.singleGeometry: " & singleGeometry
    On Error GoTo 0
    Exit Property
    
VBA_Error_Exit:
    singleGeometry = "ORCA_XYZ.singleGeometry: VBA Error " & Err.Number & ": " & Err.Description
    Err.Clear
    On Error GoTo 0
    Exit Property
    
End Property

Property Get atomDistance( _
            ByVal geomNum As Long, _
            ByVal atomIdx1 As Long, _
            ByVal atomIdx2 As Long _
            ) As Variant
    
    ' Distance in Bohrs between the two indicated atoms
    
    Dim workVec As Variant, workDbl As Double, iter As Long
    
    ' If not initialized, dump with Empty
    If Not Initialized Then
        atomDistance = Empty
        Exit Property
    End If
    
    ' Debug mode
    If DEBUG__MODE__ Then
        On Error GoTo 0
    Else
        On Error GoTo VBA_Error_Exit
    End If
    
    ' Retrieve the relevant geometry; passing out any error behavior
    workVec = Me.singleGeometry(geomNum)
    If Not IsArray(workVec) Then
        atomDistance = workVec
        GoTo Error_Exit
    End If
    
    ' Confirm provided atom numbers are valid
    If atomIdx1 < 1 Or atomIdx2 < 1 Or _
            atomIdx1 > Me.numOfAtoms Or _
            atomIdx2 > Me.numOfAtoms Then
        ' Not within range of atoms present
        atomDistance = "Invalid atom number(s) provided"
        GoTo Error_Exit
    Else
        ' Both are within range -- calculate the distance
        workDbl = 0#
       ' idx1 = parms(val)
       ' idx2 = parms(val + 1)
        For iter = 1 To 3
            workDbl = workDbl + ( _
                    workVec(3 * (atomIdx1 - 1) + iter, 1) - _
                    workVec(3 * (atomIdx2 - 1) + iter, 1) _
                                ) ^ 2
        Next iter
        atomDistance = Sqr(workDbl)
    End If
    
    ' Reset error handler; successful return
    On Error GoTo 0
    Exit Property
    
Error_Exit:
    atomDistance = "ORCA_XYZ.atomDistance: " & atomDistance
    On Error GoTo 0
    Exit Property
    
VBA_Error_Exit:
    atomDistance = "ORCA_XYZ.atomDistance: VBA Error " & Err.Number & ": " & Err.Description
    Err.Clear
    On Error GoTo 0
    Exit Property
    
End Property



'  ===  CLASS EVENTS  ===
Private Sub Class_Initialize()
    Initialized = False
End Sub
