Attribute VB_Name = "Util_Misc"
'-------------------------------------------------------------------------------
' Name:        Util_Misc (Module)
' Purpose:     Miscellaneous utility functions for ORCA Importer
'
' Author:      Brian Skinn
'                bskinn@alum.mit.edu
'
' Created:     29 Apr 2016
' Copyright:   (c) Brian Skinn 2016
' License:     The MIT License; see "license.txt" for full license terms
'                   and contributor agreement.
'
'       This file is part of ORCA Importer, an Excel VBA add-in providing
'       memoized import functionality for output generated by the ORCA
'       quantum chemistry software program package
'       (http://orcaforum.cec.mpg.de).
'
'       http://www.github.com/bskinn/excel-orcaimport
'
'-------------------------------------------------------------------------------

Option Explicit
Option Base 1

' Most (all?) of these functions will handle Arrays of any dimension base,
'  but all are configured to return Base 1 Arrays.  This is, in part,
'  in order to ensure that the Excel worksheet interface plays nicely
'  with them.

Public Function arrayify(ByVal item As Variant) As Variant
    ' Wrapper primarily for converting a possible Range input to a matrix
    '  Ranges with more than one array will return Empty
    ' Will also coerce single numeric or string inputs to a 1x1 matrix
    ' Other object types will return Empty
    
    Dim workVt As Variant
    
    If IsObject(item) Then
        If TypeOf item Is Range Then
            If item.Areas.Count = 1 Then
                ' The Value2 property returns the range contents
                '  as an Array
                arrayify = item.Value2
                If Not IsArray(arrayify) Then
                    ' Excel finds only a single value and returns
                    '  as the bare value. Wrap in an array.
                    ReDim workVt(1 To 1, 1 To 1)
                    workVt(1, 1) = item
                    arrayify = workVt
                End If
            Else
                arrayify = Empty
            End If
        Else
            arrayify = Empty
        End If
    ElseIf IsArray(item) Then
        arrayify = item
    Else
        ReDim workVt(1 To 1, 1 To 1)
        workVt(1, 1) = item
        arrayify = workVt
    End If
End Function

Public Function dearrayify(var As Variant) As Variant
    ' If 'var' is a singleton array, returns the single element
    '  with the surrounding array character stripped
    ' Otherwise, the input value is returned unmodified.
    '
    ' Will crash if passed an object
    '
    
    If IsArray(var) Then
        Select Case arrRank(var)
        Case 1
            If LBound(var, 1) = UBound(var, 1) Then
                dearrayify = var(LBound(var, 1))
                Exit Function
            End If
        Case 2
            If LBound(var, 1) = UBound(var, 1) And _
                        LBound(var, 2) = UBound(var, 2) Then
                dearrayify = var(LBound(var, 1), LBound(var, 2))
                Exit Function
            End If
        End Select
    End If
    
    ' If not suitable for de-arraying, just return
    dearrayify = var
    
End Function

Public Function arrRank(ByVal arr As Variant) As Long
    ' Return the rank (number of dimensions) of an input array.
    '
    ' Raises RTE #13 (type mismatch) if `arr` is not actually an Array
    
    Dim iter As Long, dummyVal As Long
    
    ' Must be an array
    assertIsArray arr
    
    ' Initialize the iterator so the pre-increment starts at one
    iter = 0
    
    ' Turn off exception handling
    On Error Resume Next
    
    ' Loop until an error occurs
    Do
        iter = iter + 1
        dummyVal = UBound(arr, iter)
    Loop Until Err.Number <> 0
    
    ' Reset error handling
    Err.Clear
    On Error GoTo 0
    
    ' Desired value will be one less than where the error occurs
    arrRank = iter - 1
    
End Function

Public Function mtxSpecs(ByVal mtx As Variant) As Scripting.Dictionary

    ' A zero value for msDim2 indicates a 1-D vector. msLB2 and msUB2
    '  will be stored as -1 in this case.

    Dim dict As New Scripting.Dictionary

    ' arrayify input; complain if not an array
    mtx = arrayify(mtx)
    If Not IsArray(mtx) Then
        Err.Raise Number:=13, Description:="Not an array"
    End If
    
    ' Complain if not rank two or rank one
    If Not (arrRank(mtx) = 2 Or arrRank(mtx) = 1) Then
        Err.Raise Number:=13, Description:="mtx must be 1-D or 2-D"
    End If
    
    ' Pull dimensions &c.
    ' Always going to be a first dimension
    dict.Add msLB1, LBound(mtx, 1)
    dict.Add msUB1, UBound(mtx, 1)
    dict.Add msDim1, (UBound(mtx, 1) - LBound(mtx, 1) + 1)
    
    ' May not be a second dimension
    If arrRank(mtx) = 2 Then
        ' It's there; just calculate
        dict.Add msLB2, LBound(mtx, 2)
        dict.Add msUB2, UBound(mtx, 2)
        dict.Add msDim2, (UBound(mtx, 2) - LBound(mtx, 2) + 1)
        dict.Add msNumEl, (dict.item(msDim1) * dict.item(msDim2))
    Else
        ' Nope, 1-D
        dict.Add msLB2, -1
        dict.Add msUB2, -1
        dict.Add msDim2, 0
        dict.Add msNumEl, dict.item(msDim1)
    End If
    
    ' Assign the return value
    Set mtxSpecs = dict
    
End Function

Public Function identityMatrix(ByVal length As Long) As Variant
    ' Diagonal matrix of all ones; 'length' must be positive
    assertPositive length
    identityMatrix = vToDiag(identityVector(length))
    
End Function

Public Function identityVector(ByVal length As Long) As Variant
    ' Column vector of all ones
    
    Dim workVt As Variant
    Dim iter As Long
    
    ' 'length' must be positive
    assertPositive length
    
    ReDim workVt(1 To length, 1 To 1)
    
    For iter = 1 To length
        workVt(iter, 1) = 1#
    Next iter
    
    identityVector = workVt
    
End Function

Public Function deltaFxn(ByVal val1 As Long, ByVal val2 As Long) As Long
    If val1 = val2 Then
        deltaFxn = 1
    Else
        deltaFxn = 0
    End If
End Function

Public Function ORCADebug(debugActive As Boolean) As Boolean
    ' Utility to allow quick in-sheet switching of debug flag
    ThisWorkbook.DEBUG_FLAG = debugActive
    ORCADebug = debugActive
End Function

Public Function ORCAVolatile(volActive As Boolean) As Boolean
    ' Utility to allow quick in-sheet switch of global Application.Volatile flag
    ThisWorkbook.VOLATILE_FLAG = volActive
    ORCAVolatile = volActive
End Function

Public Function ORCA_Thermo( _
            ByVal outputFile As String, _
            ByVal rotSym As Long, _
            ByVal direction As vectorDirection _
            ) As Variant
    
    ' Function to retrieve thermodynamic parameters from a frequency/thermo ORCA calculation
    '
    ' Function is planned only for use as a worksheet function, so don't worry about
    '  detailed error handling.  String-based should be fine
    '
    ' Return vector elements are:
    '  1  - Temperature
    '  2  - Pressure
    '  3  - Electronic energy
    '  4  - Harmonic ZPE
    '  5  - Vibrational thermal contribution to E
    '  6  - Rotational thermal contribution to E
    '  7  - Translational thermal contribution to E
    '  8  - Ideal-gas (kB*T) enthalpy factor
    '  9  - Electronic T*S
    '  10 - Vibrational T*S
    '  11 - Rotational T*S (corrected according to rotSym parameter)
    '  12 - Translational T*S
    '
    
    Dim rx As New RegExp, wsf As WorksheetFunction, mch As Match
    Dim tStrm As TextStream, fileText As String
    Dim str As String, str2 As String
    Dim outVt As Variant
    Dim iter As Long
    Dim fs As FileSystemObject
    Const numEls As Long = 12
    Const notFoundStr As String = "NF"
    
    Const gasConst As Double = 3.1647141251652E-06    ' Eh / K
    
    ' Drop to catch-all error reporter
    'On Error GoTo VBA_Error_Exit
    
    ' Assign the worksheet function object
    Set wsf = Application.WorksheetFunction
    
    ' Default 'nothing happened' return value
    ORCA_Thermo = "No return value set"
    
    ' Re-dimension the output variant as a column vector; will transpose before
    '  function return if row vector is requested
    ReDim outVt(1 To numEls, 1 To 1)
    
    ' Catch the special "Labels" input string
    If UCase(outputFile) = "LABELS" Then
        outVt(1, 1) = "T (K)"
        outVt(2, 1) = "P (atm)"
        outVt(3, 1) = "E_elec"
        outVt(4, 1) = "E_ZPE"
        outVt(5, 1) = "E_th,vib"
        outVt(6, 1) = "E_th,rot"
        outVt(7, 1) = "E_th,tr"
        outVt(8, 1) = "k_B*T"
        outVt(9, 1) = "T*S_el"
        outVt(10, 1) = "T*S_vib"
        outVt(11, 1) = "T*S_rot"
        outVt(12, 1) = "T*S_tr"
        
        Select Case direction
        Case vdRowVector
            ORCA_Thermo = wsf.Transpose(outVt)
        Case vdColVector
            ORCA_Thermo = outVt
        End Select
        
        Exit Function
    End If
    
    ' Bind filesystem object
    Set fs = CreateObject("Scripting.FileSystemObject")
    
    ' Check that indicated file exists
    If Not fs.FileExists(outputFile) Then
        ORCA_Thermo = "File not found"
        Exit Function
    End If
    
    ' Open file, pull contents, and close
    Set tStrm = fs.OpenTextFile(outputFile, ForReading, False, TristateFalse)
    fileText = tStrm.ReadAll
    tStrm.Close
  
    With rx
        ' Build the Regex to capture everything from the
        '  thermodynamics section, to the end of the file.
        .MultiLine = False
        .Global = False
        .IgnoreCase = True
        .Pattern = "[-]+\s*\n\s*THERMOCHEMISTRY([^\n]|\n)*"
        If Not .Test(fileText) Then
            ORCA_Thermo = "Thermo section not found"
            Exit Function
        End If
        str = .Execute(fileText)(0).Value
        
        ' Retrieve the needed pieces of output and add to the vector
        ' TEMPERATURE
        .Pattern = "temperature[^.]+\.+[^0-9]*([0-9.]+)\s+K"
        If Not .Test(str) Then
            'ORCA_Thermo = "Simulation temperature not found"
            'Exit Function
            outVt(1, 1) = notFoundStr
        Else
            'Set mch = .Execute(str)(0)
            outVt(1, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' PRESSURE
        .Pattern = "pressure[^.]+\.+[^0-9]*([0-9.]+)\s+atm"
        If Not .Test(str) Then
            'ORCA_Thermo = "Simulation pressure not found"
            'Exit Function
            outVt(2, 1) = notFoundStr
        Else
            'Set mch = .Execute(str)(0)
            outVt(2, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ELECTRONIC ENERGY
        .Pattern = "electronic energy[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            'ORCA_Thermo = "Electronic energy not found"
            'Exit Function
            outVt(3, 1) = notFoundStr
        Else
            'Set mch = .Execute(str)(0)
            outVt(3, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ZERO-POINT ENERGY
        .Pattern = "zero point energy[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(4, 1) = notFoundStr
        Else
            outVt(4, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' VIBRATIONAL THERMAL CORRECTION
        .Pattern = "thermal vibrational correction[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(5, 1) = notFoundStr
        Else
            outVt(5, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ROTATIONAL THERMAL CORRECTION
        .Pattern = "thermal rotational correction[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(6, 1) = notFoundStr
        Else
            outVt(6, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' TRANSLATIONAL THERMAL CORRECTION
        .Pattern = "thermal translational correction[^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(7, 1) = notFoundStr
        Else
            outVt(7, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' IDEAL-GAS ENTHALPY CORRECTION
        .Pattern = "thermal enthalpy correction [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(8, 1) = notFoundStr
        Else
            outVt(8, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ELECTRONIC ENTROPY
        .Pattern = "electronic entropy [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(9, 1) = notFoundStr
        Else
            outVt(9, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' VIBRATIONAL ENTROPY
        .Pattern = "vibrational entropy [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(10, 1) = notFoundStr
        Else
            outVt(10, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
        ' ROTATIONAL ENTROPY
        .Pattern = "thermal rotational correction [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            ' Don't bother calculating this if there was a glitch in
            '  the automated rotational entropy calculation
            outVt(11, 1) = notFoundStr
        Else
            ' Must retrieve the rotational partition function and compute new
            '  entropy value
            .Pattern = "\s+qrot =\s*([0-9.]+)\s*\n"
            outVt(11, 1) = gasConst * ( _
                    wsf.Ln(CDbl(.Execute(str)(0).SubMatches(0)) / CDbl(rotSym)) + 1.5 _
                    ) * outVt(1, 1)
        End If
        
        ' TRANSLATIONAL ENTROPY
        .Pattern = "translational entropy [^.]+\.+[^0-9-]*([0-9.-]+)\s+eh"
        If Not .Test(str) Then
            outVt(12, 1) = notFoundStr
        Else
            outVt(12, 1) = CDbl(.Execute(str)(0).SubMatches(0))
        End If
        
    End With
    
    ' Store the resulting vector in the appropriate orientation
    Select Case direction
    Case vdColVector
        ORCA_Thermo = outVt
    Case vdRowVector
        ORCA_Thermo = wsf.Transpose(outVt)
    End Select
    
    
    Exit Function
    
VBA_Error_Exit:
    ORCA_Thermo = "VBA error"
    Exit Function
    
End Function

