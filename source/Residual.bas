Attribute VB_Name = "Residual"
'-------------------------------------------------------------------------------
' Name:        Residual (Module)
' Purpose:     Residual code from prior private implementation.
'
' Author:      Brian Skinn
'                bskinn@alum.mit.edu
'
' Created:     30 Apr 2016
' Copyright:   (c) Brian Skinn 2016
' License:     The MIT License; see "license.txt" for full license terms
'                   and contributor agreement.
'
'       This file is part of ORCA Importer, an Excel VBA add-in providing
'       memoized import functionality for output generated by the ORCA
'       quantum chemistry software program package
'       (http://orcaforum.cec.mpg.de).
'
'       http://www.github.com/bskinn/excel-orcaimport
'
'-------------------------------------------------------------------------------

Option Explicit
Option Base 1

'Public Function mtxOrthonormCheck(ByVal Matrix As Variant, _
'        Optional ByVal orthonormTol As Double = DEF_Orthonorm_Tol) As VbTriState
'    ' ##TODO## Convert to string return type!
'
'    ' Columnwise check for orthonormality of a matrix
'    ' Matrix does not have to be square
'    ' Function assumes that both dimensions of 'matrix' are Base 1
'    ' vbUseDefault return indicates invalid 'matrix' argument passed
'
'    Dim iter As Long, iter2 As Long
'    Dim vecs As Variant
'
'    ' Initialize return to success; any non-orthonorm result will crash to fail
'    mtxOrthonormCheck = vbTrue
'
'    ' Matrixify input if needed
'    Matrix = matrixify(Matrix)
'    If IsEmpty(Matrix) Then
'        mtxOrthonormCheck = vbUseDefault
'        Exit Function
'    End If
'
'    ' Perform check
'    For iter = 1 To UBound(Matrix, 2)
'        For iter2 = iter To UBound(Matrix, 2)
'            If Abs(ProdScal(MCol(Matrix, iter), MCol(Matrix, iter2))) - _
'                    CDbl(deltaFxn(iter, iter2)) > orthonormTol Then
'                mtxOrthonormCheck = vbFalse
'                Exit Function
'            End If
'        Next iter2
'    Next iter
'
'End Function
'
'Public Function vecsOrthonormCheck(ParamArray vecs()) As VbTriState
'    ' ##TODO## CONVERT TO STRING RETURN TYPE
'    Dim maxVecIdx As Long, vecLength As Long
'    Dim iter As Long, iter2 As Long
'    Dim orthonormTol As Double
'
'    ' ParamArray is always Base 0, regardless of Option Base setting
'    ' A single double value can be passed as the last argument to adjust
'    '  the orthonormality tolerance. Otherwise, the default value is used.
'
'    ' No-good return if no argument passed
'    If IsMissing(vecs) Then
'        vecsOrthonormCheck = vbUseDefault
'        Exit Function
'    End If
'
'    ' Store the index of the last element in the vector array
'    maxVecIdx = UBound(vecs)
'
'    ' Check if the last element is a non-array single value. If so, treat as the tolerance
'    '  and decrement the max vector index (crashing out if this leaves no vectors).
'    '  Otherwise, set the default tolerance.
'    If IsNumeric(vecs(maxVecIdx)) Then
'        orthonormTol = CDbl(vecs(maxVecIdx))
'        If maxVecIdx > 0 Then
'            maxVecIdx = maxVecIdx - 1
'        Else
'            vecsOrthonormCheck = vbUseDefault
'            Exit Function
'        End If
'    Else
'        orthonormTol = DEF_Orthonorm_Tol
'    End If
'
'    ' Matrixify all of the vectors, dumping out if any arguments aren't workable
'    For iter = 0 To maxVecIdx
'        vecs(iter) = matrixify(vecs(iter))
'        If IsEmpty(vecs(iter)) Then
'            vecsOrthonormCheck = vbUseDefault
'            Exit Function
'        End If
'    Next iter
'
'    ' Store the length of the first vector
'    vecLength = UBound(vecs(0), 1)
'
'    ' Check to ensure all vectors are this length, crashing out if not
'    For iter = 0 To maxVecIdx
'        If UBound(vecs(iter), 1) <> vecLength Then
'            vecsOrthonormCheck = vbUseDefault
'            Exit Function
'        End If
'    Next iter
'
'    ' Initialize the success return
'    vecsOrthonormCheck = vbTrue
'
'    ' Loop through the vectors, confirming orthonormality.
'    ' If any fail, set the fail return and dump from function.
'    For iter = 0 To maxVecIdx
'        For iter2 = iter To maxVecIdx
'            If (Abs(ProdScal(vecs(iter), vecs(iter2))) - deltaFxn(iter, iter2)) _
'                    > CDbl(orthonormTol) Then
'                vecsOrthonormCheck = vbFalse
'                Exit Function
'            End If
'        Next iter2
'    Next iter
'
'End Function



Public Function rotConstUnitName(rcuType As RotConstUnits) As String
    
    Select Case rcuType
    Case rcuInvInertia
        rotConstUnitName = "1/(amu*B^2)"
    Case rcuAngFreqAtomic
        rotConstUnitName = "1/Ta"
    Case rcuAngFreqSeconds
        rotConstUnitName = "1/s"
    Case rcuCyclicFreqAtomic
        rotConstUnitName = "cyc/Ta"
    Case rcuCyclicFreqSeconds
        rotConstUnitName = "cyc/s"
    Case rcuCyclicFreqMHz
        rotConstUnitName = "MHz"
    Case rcuWaveNumAtomic
        rotConstUnitName = "cyc/B"
    Case rcuWaveNumCm
        rotConstUnitName = "cyc/cm"
    End Select
    
End Function

Public Function topTypeName(tType As MolecularTopType) As String

    Select Case tType
    Case topAsymmetrical
        topTypeName = "Asymmetrical"
    Case topAtom
        topTypeName = "Atom"
    Case topInvalid
        topTypeName = "INVALID"
    Case topLinear
        topTypeName = "Linear"
    Case topSpherical
        topTypeName = "Spherical"
    Case topSymmetricalOblate
        topTypeName = "Oblate Symmetrical"
    Case topSymmetricalProlate
        topTypeName = "Prolate Symmetrical"
    Case topUninitialized
        topTypeName = "UNINITIALIZED"
    End Select
    
End Function

Public Function pyMatrix(rg As Variant, Optional rowLines As Long = 0, _
        Optional leadSpaces As Long = 8, Optional asStrings As Boolean = False) As Variant

    ' 1-D arrays will (probably) always be reported as column vectors due to VBA's capricious
    '  dimensional reduction.

    Dim workStr As String, newLineStr As String
    Dim i As Long, j As Long
    Dim is2D As Boolean, errNum As Long
    
    ' Build the newline string
    newLineStr = vbLf & Application.WorksheetFunction.Rept(" ", leadSpaces)
    
    ' Initialize empty result
    workStr = "["
    
    If Not TypeOf rg Is Range Then
        ' Check dimensionality
        On Error Resume Next
            is2D = (LBound(rg, 2) >= -1000)
            errNum = Err.Number
            Err.Clear
        On Error GoTo 0
        
        Select Case errNum
        Case 0
            ' All is well; 2nd dim exists
        Case 9
            ' 1-D array; indicate and continue
            is2D = False
        Case Else
            ' Some other error; reraise
            Err.Raise errNum
        End Select
    
        ' Loop over array bounds
        For i = LBound(rg, 1) To UBound(rg, 1)
            ' Open new bracket
            workStr = workStr & "["
            
            ' Handle depending on dimensionality
            If is2D Then
                For j = LBound(rg, 2) To UBound(rg, 2)
                    ' Fill the string; bracket with strings if indicated
                    If asStrings Then workStr = workStr & "'"
                    workStr = workStr & CStr(rg(i, j))
                    If asStrings Then workStr = workStr & "'"
                    workStr = workStr & ","
                Next j
                
                ' Swap the last character to a close bracket & add comma
                workStr = Left(workStr, Len(workStr) - 1) & "],"
                
                ' Only newline if indicated
                If rowLines > 0 Then
                    If i Mod rowLines = 0 Then
                        workStr = workStr & newLineStr
                    End If
                End If
            Else
                ' Fill the string; bracket with strings if indicated
                If asStrings Then workStr = workStr & "'"
                workStr = workStr & CStr(rg(i))
                If asStrings Then workStr = workStr & "'"
                workStr = workStr & ","
                
                ' Swap the last character to a close bracket & add comma
                workStr = Left(workStr, Len(workStr) - 1) & "],"
                
                ' Only newline if indicated
                If rowLines > 0 Then
                    If i Mod rowLines = 0 Then
                        workStr = workStr & newLineStr
                    End If
                End If
            End If
        Next i
    Else ' Assume Range
        For i = 1 To rg.Rows.Count
            ' Open new bracket
            workStr = workStr & "["
            
            For j = 1 To rg.Columns.Count
                ' Fill the string; bracket with strings if indicated
                If asStrings Then workStr = workStr & "'"
                workStr = workStr & CStr(rg.Cells(i, j))
                If asStrings Then workStr = workStr & "'"
                workStr = workStr & ","
            Next j
            
            ' Swap the last character to a close bracket & add comma
            workStr = Left(workStr, Len(workStr) - 1) & "],"
            
            ' Only newline if indicated
            If rowLines > 0 Then
                If i Mod rowLines = 0 Then
                    workStr = workStr & newLineStr
                End If
            End If
        Next i
    End If
    
    ' Replace the last one or two characters (comma, plus newline) with a close bracket
    If Right(workStr, Len(newLineStr)) = newLineStr Then
        workStr = Left(workStr, Len(workStr) - (1 + Len(newLineStr))) & "]"
    Else
        workStr = Left(workStr, Len(workStr) - 1) & "]"
    End If
    
    ' Return the string
    pyMatrix = workStr
    
End Function


