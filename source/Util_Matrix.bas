Attribute VB_Name = "Util_Matrix"
'-------------------------------------------------------------------------------
' Name:        Util_Matrix (Module)
' Purpose:     Helper functions for ORCA Importer taking 2-D array inputs
'
' Author:      Brian Skinn
'                bskinn@alum.mit.edu
'
' Created:     11 May 2016
' Copyright:   (c) Brian Skinn 2016
' License:     The MIT License; see "license.txt" for full license terms
'                   and contributor agreement.
'
'       This file is part of ORCA Importer, an Excel VBA add-in providing
'       memoized import functionality for output generated by the ORCA
'       quantum chemistry software program package
'       (http://orcaforum.cec.mpg.de).
'
'       http://www.github.com/bskinn/excel-orcaimport
'
'-------------------------------------------------------------------------------

Option Explicit
Option Base 1

' Matrix functions can only take 2-D arrays. Other constraints are specified
'  on a per-function basis.

' Most (all?) of these functions will handle Arrays of any dimension base,
'  but all are configured to return Base 1 Arrays.  This is, in part,
'  in order to ensure that the Excel worksheet interface plays nicely
'  with them.

Public Function mNorm(ByVal mtx As Variant) As Variant
    ' Return the 2-norm of the input matrix
    ' NOTE: WORKS FINE ON 1XN "ROW VECTORS" IF DO NOT WANT THEM TRANSPOSED
    
    Dim iter1 As Long, iter2 As Long, accum As Double
    Dim mSpecs As Scripting.Dictionary
    
    ' arrayify the input
    mtx = arrayify(mtx)
    
    ' Complain if not converted to array
    assertIsArray mtx
    
    ' Insist on 2-D
    assertIs2D mtx
    
    ' Store the dimensions for convenience and redim the working Variant
    Set mSpecs = mtxSpecs(mtx)
    
    ' Iterate over the whole thing and accumulate the squares of the elements
    accum = 0#
    For iter1 = mSpecs(msLB1) To mSpecs(msUB1)
        For iter2 = mSpecs(msLB2) To mSpecs(msUB2)
            accum = accum + mtx(iter1, iter2) ^ 2#
        Next iter2
    Next iter1
    
    ' Return the square root of the accumulator
    mNorm = accum ^ 0.5
    
End Function

Public Function mNormalize(ByVal mtx As Variant) As Variant
    ' Normalize input matrix (2-norm) across the full contents
    '  of a 2-D Array
    '
    ' Raises RTE #13 (type mismatch) if matrixified version
    '  is not an Array
    
    Dim workVt() As Variant, iter1 As Long, iter2 As Long
    Dim normVal As Double
    Dim mSpecs As Scripting.Dictionary
    
    ' arrayify the input
    mtx = arrayify(mtx)
    
    ' Complain if it wasn't converted to an Array
    assertIsArray mtx
    
    ' Complain if it's not 2-D
    assertIs2D mtx
    
    ' Store the dimensions for convenience and redim the working Variant
    Set mSpecs = mtxSpecs(mtx)
    ReDim workVt(1 To mSpecs(msDim1), 1 To mSpecs(msDim2))
    
    ' Retrieve the matrix norm
    normVal = mNorm(mtx)
    
    ' Iterate again and store each normalized element to the working Variant
    For iter1 = 1 To mSpecs(msDim1)
        For iter2 = 1 To mSpecs(msDim2)
            workVt(iter1, iter2) = (1# / normVal) * _
                        mtx(mSpecs(msLB1) - 1 + iter1, mSpecs(msLB2) - 1 + iter2)
        Next iter2
    Next iter1
    
    ' Return the working matrix
    mNormalize = workVt
    
End Function

Public Function mReshape(ByVal arr As Variant, newRows As Long, _
                        newCols As Long) As Variant
    ' Change the shape of a 2-D array. The new shape must
    '  have the same total number of elements as the old.
    ' Input and output element ordering is row-major.
    '
    ' Raises RTE #13 (type mismatch) on a dimension mismatch
    
    Dim workVt As Variant, inVt As Variant, wsf As WorksheetFunction
    Dim iter As Long, iter2 As Long
    Dim mSpecs As Scripting.Dictionary
    
    ' Must be an input array
    inVt = arrayify(arr)
    assertIsArray inVt
    
    ' Must be 1-D or 2-D
    assertIs1Or2D inVt
    
    ' New size dimensions must be positive
    assertPositive newRows
    assertPositive newCols
    
    ' Store the dimension info and bind the worksheet function obj
    Set mSpecs = mtxSpecs(inVt)
    Set wsf = Application.WorksheetFunction
    
    ' Handle the two different dimensionality cases separately
    If mSpecs(msDim2) = 0 Then
        ' 1-D -- Dimensions must be compatible
        If (mSpecs(msUB1) - mSpecs(msLB1) + 1) <> (newRows * newCols) Then
            Err.Raise Number:=13, Description:="Incompatible resize dimensions"
        End If
        
        ' Redim and fill
        ReDim workVt(1 To newRows, 1 To newCols)
        For iter = 0 To (newCols * newRows - 1)
            workVt(wsf.Floor(iter / newCols, 1) + 1, (iter Mod newCols) + 1) = _
                                inVt(mSpecs(msLB1) + iter)
        Next iter
    Else
        ' 2-D -- Dimensions must be compatible
        If ((mSpecs(msUB1) - mSpecs(msLB1) + 1) * _
            (mSpecs(msUB2) - mSpecs(msLB2) + 1)) <> (newRows * newCols) Then
            Err.Raise Number:=13, Description:="Incompatible resize dimensions"
        End If
        
        ' Redim and fill
        ReDim workVt(1 To newRows, 1 To newCols)
        For iter = 0 To (newCols * newRows - 1)
            workVt(wsf.Floor(iter / newCols, 1) + 1, (iter Mod newCols) + 1) = _
                    inVt(wsf.Floor(iter / mSpecs(msDim2), 1) + 1, (iter Mod mSpecs(msDim2)) + 1)
        Next iter
    End If
    
    ' Store the return array
    mReshape = workVt
    
End Function

Public Function mTile(ByVal mtx As Variant, ByVal repVert As Long, _
                                            ByVal repHoriz As Long) As Variant
    ' Tile-repeat copies of the 2-D input matrix the indicated number of times
    '
    ' This could probably be economized by clustering some stacking depending
    '  on the particular numbers of repeats requested
    
    Dim iter As Long
    Dim workVt As Variant, midVt As Variant
    
    ' Initialize the working Variant
    workVt = arrayify(mtx)
    
    ' Assert the input is an array and is 2-D
    assertIsArray workVt
    assertIs2D workVt
    
    ' Replicate parameters must be positive
    assertPositive repVert
    assertPositive repHoriz
    
    ' Horizontal stacks
    For iter = 1 To (repHoriz - 1)
        workVt = mStackHoriz(workVt, mtx)
    Next iter
    
    ' Store the horiz-stacked arrray
    midVt = workVt
    
    ' Vertical stacks
    For iter = 1 To (repVert - 1)
        workVt = mStackVert(workVt, midVt)
    Next iter
    
    ' Store the return value
    mTile = workVt
    
End Function

Public Function mExpand(ByVal mtx As Variant, ByVal expRows As Long, _
                                            ByVal expCols As Long) As Variant
    ' Expand each element of the input matrix into a 'vert x horiz' submatrix
    '  of the output
    
    Dim iterCol As Long, iterRow As Long
    Dim repIterCol As Long, repIterRow As Long
    Dim workVt As Variant
    Dim mSpecs As Scripting.Dictionary
    
    ' Assert 2-D array
    mtx = arrayify(mtx)
    assertIsArray mtx
    assertIs2D mtx
    
    ' Expansion values must be positive
    assertPositive expRows
    assertPositive expCols
    
    ' Store matrix dimension properties
    Set mSpecs = mtxSpecs(mtx)
    
    ' Dimension the new array
    ReDim workVt(1 To expRows * mSpecs(msDim1), 1 To expCols * mSpecs(msDim2))
    
    ' Iterate over the original matrix
    For iterRow = 1 To mSpecs(msDim1)
        For iterCol = 1 To mSpecs(msDim2)
            ' Replicate each entry the indicated number of times into the output
            ' array
            For repIterRow = 1 To expRows
                For repIterCol = 1 To expCols
                    workVt((iterRow - 1) * expRows + repIterRow, _
                                (iterCol - 1) * expCols + repIterCol) = _
                            mtx(mSpecs(msLB1) - 1 + iterRow, mSpecs(msLB2) - 1 + iterCol)
                Next repIterCol
            Next repIterRow
        Next iterCol
    Next iterRow
    
    ' Store the return value
    mExpand = workVt
    

End Function

Public Function mCol(ByVal Matrix As Variant, ByVal colIndex As Long) As Variant
    Dim iter As Long, workVt As Variant
    Dim mSpecs As Scripting.Dictionary
    
    ' No need to handle bad index explicitly; standard VBA error will be thrown
    
    ' arrayify input; complain if not a 2-D array
    Matrix = arrayify(Matrix)
    assertIsArray Matrix
    assertIs2D Matrix
    
    ' Pull dimensions
    Set mSpecs = mtxSpecs(Matrix)
    
    ' Column index must be valid
    assertBetween colIndex, mSpecs(msLB2), mSpecs(msUB2), True
    
    ' Redim the work variant and pull out the desired column
    ReDim workVt(1 To mSpecs(msDim1), 1 To 1)
    For iter = 1 To mSpecs(msDim1)
        workVt(iter, 1) = Matrix(mSpecs(msLB1) + iter - 1, colIndex)
    Next iter
    
    ' Store the return value
    mCol = workVt
    
End Function

Public Function mRow(ByVal Matrix As Variant, ByVal rowIndex As Long) As Variant
    Dim iter As Long, workVt As Variant
    Dim mSpecs As Scripting.Dictionary
    
    ' No need to handle bad index explicitly; standard VBA error will be thrown
    
    ' arrayify input; complain if not a 2-D array
    Matrix = arrayify(Matrix)
    assertIsArray Matrix
    assertIs2D Matrix
    
    ' Pull dimensions
    Set mSpecs = mtxSpecs(Matrix)
    
    ' Row index must be valid
    assertBetween rowIndex, mSpecs(msLB1), mSpecs(msUB1), True
    
    ' Resize the output variant and fill the desired row
    ReDim workVt(1 To 1, 1 To mSpecs(msDim2))
    For iter = 1 To mSpecs(msUB2)
        workVt(1, iter) = Matrix(rowIndex, iter)
    Next iter
    
    mRow = workVt
    
End Function

Public Function mStackHoriz(ByVal mtx1 As Variant, ByVal mtx2 As Variant) As Variant
    ' Stack mtx1 to the left of mtx2. Number of rows must match.
    ' Likely could speed this up for large matrices by just seeding workVt
    '  with mtx1 and doing a ReDim Preserve...
    
    Dim iterCol As Long, iterRow As Long
    Dim workVt As Variant
    Dim mSpecs1 As Scripting.Dictionary, mSpecs2 As Scripting.Dictionary
    
    ' arrayify inputs; complain if either is not an array
    mtx1 = arrayify(mtx1)
    assertIsArray mtx1
    
    mtx2 = arrayify(mtx2)
    assertIsArray mtx2
    
    ' Insist that both matrices are 2-D (for now, at least)
    assertIs2D mtx1
    assertIs2D mtx2
    
    ' Pull the dimensions on both
    Set mSpecs1 = mtxSpecs(mtx1)
    Set mSpecs2 = mtxSpecs(mtx2)
    
    ' Check for row count match between matrices to be concatenated
    If mSpecs1(msDim1) <> mSpecs2(msDim1) Then
        Err.Raise Number:=9, _
                Description:="Subscript out of bounds: Matrix row count mismatch"
    End If
    
    ' Resize the output matrix to contain both input matrices
    ReDim workVt(1 To mSpecs1(msDim1), 1 To (mSpecs1(msDim2) + mSpecs2(msDim2)))
    
    ' Populate the output matrix
    For iterCol = 1 To UBound(workVt, 2)       ' Columns outer
        For iterRow = 1 To UBound(workVt, 1)   ' Rows inner
            If iterCol <= mSpecs1(msDim2) Then
                ' First matrix data
                workVt(iterRow, iterCol) = _
                        mtx1(iterRow - 1 + mSpecs1(msLB1), iterCol - 1 + mSpecs1(msLB2))
            Else
                ' Second matrix data
                workVt(iterRow, iterCol) = _
                        mtx2(iterRow - 1 + mSpecs2(msLB1), _
                                iterCol - 1 - mSpecs1(msDim2) + mSpecs2(msLB2))
            End If
        Next iterRow
    Next iterCol
    
    ' Set the return value
    mStackHoriz = workVt
    
End Function

Public Function mStackVert(ByVal mtx1 As Variant, ByVal mtx2 As Variant) As Variant
    ' Stack mtx1 atop mtx2. Number of columns must match
    ' Likely could speed this up for large matrices by just seeding workVt
    '  with mtx1 and doing a ReDim Preserve...
    
    Dim iterCol As Long, iterRow As Long
    Dim workVt As Variant
    Dim mSpecs1 As Scripting.Dictionary, mSpecs2 As Scripting.Dictionary
    
    ' arrayify inputs; complain if either is not an array
    mtx1 = arrayify(mtx1)
    assertIsArray mtx1
    
    mtx2 = arrayify(mtx2)
    assertIsArray mtx2
    
    ' Insist that both matrices are 2-D (for now, at least)
    assertIs2D mtx1
    assertIs2D mtx2
    
    ' Pull the dimensions on both
    Set mSpecs1 = mtxSpecs(mtx1)
    Set mSpecs2 = mtxSpecs(mtx2)
    
    ' Check for column count match between matrices to be concatenated
    If mSpecs1(msDim2) <> mSpecs2(msDim2) Then
        Err.Raise Number:=9, _
                Description:="Subscript out of bounds: Matrix column count mismatch"
    End If
    
    ' Resize the output matrix to contain both input matrices
    ReDim workVt(1 To (mSpecs1(msDim1) + mSpecs2(msDim1)), 1 To mSpecs1(msDim2))
    
    ' Populate the output matrix
    For iterCol = 1 To UBound(workVt, 2)           ' Columns outer
        For iterRow = 1 To UBound(workVt, 1)      ' Rows inner
            If iterRow <= mSpecs1(msDim1) Then
                ' First matrix data
                workVt(iterRow, iterCol) = _
                        mtx1(iterRow - 1 + mSpecs1(msLB1), iterCol - 1 + mSpecs1(msLB2))
            Else
                ' Second matrix data
                workVt(iterRow, iterCol) = _
                        mtx2(iterRow - 1 - mSpecs1(msDim1) + mSpecs2(msLB1), _
                                iterCol - 1 + mSpecs2(msLB2))
            End If
        Next iterRow
    Next iterCol
    
    ' Store the return value
    mStackVert = workVt
    
End Function

Public Function mTranspose(ByVal mtx As Variant) As Variant
    ' Wrapper around WorksheetFunction.Transpose for the sake of
    '  concision. May be subtle fragile?
    
    Dim wsf As WorksheetFunction
    
    ' Ensure input is a 2-D array
    mtx = arrayify(mtx)
    assertIsArray mtx
    assertIs2D mtx
    
    ' Bind wsf and calculate transpose
    Set wsf = Application.WorksheetFunction
    
    mTranspose = wsf.Transpose(mtx)
    
End Function

